package main

import (
	"encoding/json"
	"io"
	"math/bits"
	"os"
	"path/filepath"
	"strconv"
	"text/template"
)

const tmplDir string = "templates"

type TypegenConfig struct {
	HeaderPath string          `json:"header"`
	Storage    []StorageConfig `json:"storage"`
	Imports    []string
	Widths     []int
}

type StorageConfig struct {
	Name         string           `json:"name"`
	Imports      []string         `json:"imports"`
	TemplatePath string           `json:"template"`
	Options      []TemplateOption `json:"options"`
}

type TemplateOption struct {
	Width int `json:"width"`
}

func (s StorageConfig) NameFor(w int) string {
	postfix := strconv.Itoa(w)
	return s.Name + postfix
}

func fail(err error) {
	os.Stderr.WriteString(err.Error())
	os.Stderr.WriteString("\n")
	os.Exit(1)
}

func rl(x uint, y int) uint {
	return bits.RotateLeft(x, y)
}

func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}

func seq(i, j int) []int {
	if j <= i {
		return []int{}
	}
	r := make([]int, j-i)
	for k := range r {
		r[k] = i + k
	}
	return r
}

func rseq(i, j int) []int {
	if j <= i {
		return []int{}
	}
	r := make([]int, j-i)
	for k := range r {
		r[k] = j - k - 1
	}
	return r
}

var tmplFuncs template.FuncMap = template.FuncMap{
	"Add":  add,
	"Sub":  sub,
	"Seq":  seq,
	"Rseq": rseq,
	"Rl":   rl,
}

func processTemplate(out io.Writer, path string, conf interface{}) error {
	in, err := os.Open(path)
	if err != nil {
		return err
	}
	defer in.Close()

	data, err := io.ReadAll(in)
	if err != nil {
		return err
	}

	tpl, err := template.New(filepath.Base(path)).Funcs(tmplFuncs).Parse(string(data))
	if err != nil {
		return err
	}

	err = tpl.Execute(out, conf)
	if err != nil {
		return err
	}

	return nil
}

func ReadGenConfig(path string) (*TypegenConfig, error) {
	in, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer in.Close()

	data, err := io.ReadAll(in)
	if err != nil {
		return nil, err
	}

	var conf TypegenConfig
	conf.Imports = make([]string, 0)
	conf.Widths = []int{8, 16, 32, 64}

	err = json.Unmarshal(data, &conf)
	if err != nil {
		return nil, err
	}

	imports := make(map[string]bool)
	for _, stor := range conf.Storage {
		for _, pkg := range stor.Imports {
			imports[pkg] = true
		}
	}

	for module := range imports {
		conf.Imports = append(conf.Imports, module)
	}

	return &conf, nil
}

func main() {

	conf, err := ReadGenConfig("configs/types.json")
	if err != nil {
		fail(err)
	}

	out, err := os.Create("types.go")
	if err != nil {
		fail(err)
	}
	defer func() {
		err := out.Close()
		if err != nil {
			fail(err)
		}
	}()

	out.WriteString("// Code generated by typegen. DO NOT EDIT\n")

	err = processTemplate(out, filepath.Join(tmplDir, conf.HeaderPath), conf)
	if err != nil {
		fail(err)
	}

	for _, stor := range conf.Storage {
		tmplPath := filepath.Join(tmplDir, stor.TemplatePath)
		if err = processTemplate(out, tmplPath, stor); err != nil {
			fail(err)
		}
		for _, t := range stor.Options {
			os.Stderr.WriteString("Generated " + stor.NameFor(t.Width) + "\n")
		}
	}

}
