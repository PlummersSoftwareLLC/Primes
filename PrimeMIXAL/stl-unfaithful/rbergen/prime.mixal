** Register use

* rI1: general use
* rI2: factor/sieve word
* rI3: bitword/sieve bit/check table index
* rI4: run count

BTARR   ORIG	3400            Jump past bit array

** Constants and variables

* Parameters
LTSVSZ  EQU     200000          Sieve size literal. Max is 200000, due to memory size
SVSQRT  CON	447             Sqrt of sieve size variable

* Table with reference values (sieve size first, prime count second)
CHCKTBL CON     10
        CON     4
        CON     100
        CON     25
        CON     1000
        CON     168
        CON     10000
        CON     1229
        CON     100000
        CON     9592
        CON     200000
        CON     17984
        CON     -1

* Basic constants
LTBPW   EQU     5*6             Bits per word literal
ADDR    EQU     1:2             Address fspec      
PRNTR   EQU     18              Printer device number

* Constants derived from other values
LTBTCT  EQU     LTSVSZ+1/2      Sieve bit count literal
LTWDCT  EQU     LTBTCT/LTBPW    Sieve full word count literal
LTBWCT  EQU     LTWDCT*LTBPW    Sieve bits in full words literal
LTRBTCT EQU     LTBTCT-LTBWCT   Sieve bits remainder literal

* Runtime variable
SVSIZE	CON	LTSVSZ          Sieve size variable
BTPRWRD CON     LTBPW           Bits per word variable
NUM     CON     0	        Number variable (too big for rI)
PRMCNT  CON     0               Prime count variable (too big for rI)

* Text word constants
SPACES  ALF     "     "
WRONG   ALF     "WRONG"
RIGHT   ALF     "RIGHT"
UNKNO   ALF     "UNKNO"
WN      ALF     "WN   "

** Main program

START	ENT2     3              First factor is 3

* Start of factor loop
QLOOP   ENTX    0,2             Load factor into rX

* Start of num loop
NUMLOOP JXE     NXTNUM          If we're looking at an even number, skip it
        ENTA    0               Prepare rAX for division
        STX     NUM             Hang on to our number
        SRB     1               Divide by 2...
        DIV     BTPRWRD         ...and then the number of bits per werd
        STA     *+1(ADDR)       rA contains the word index, which we...
        ENT3    *               ...load into rI3...
        LDA     BTARR,3         ...so we can then load the correct word into rA
        
        STX     *+1(ADDR)       rX contains the bit number, which we put forward...
        SRB     *               ...so we can shift that bit to the right
        JAE     SETFCTR         If our bit is zero, we found our next factor
        LDX     NUM             Load number back into rX
NXTNUM  INCX    2               Bump rX to next odd number 
        CMPX    SVSQRT          If number > the sqrt of sieve size...
        JG      CNTPRM          ...we can end this run...
        JMP     NUMLOOP         ...else continue
* End of num loop        

* Found next factor
SETFCTR LD2     NUM             Load factor into rI2
        LDA     NUM             Load factor into rA...
        MUL     =3=             ...so we can start at factor * 3

* Start of loop to set bits for factor multiples
SETLOOP ENTA    0               Prepare rAX for division
        STX     NUM             Hang on to our number
        SRB     1               Divide by 2...
        DIV     BTPRWRD         ...and then the number of bits per werd
        STA     *+1(ADDR)       rA contains the word index, which we...
        ENT3    *               ...load into rI3...
        LDA     BTARR,3         ...so we can then load the correct word into rA
        STX     *+1(ADDR)       rX contains the bit number, which we put forward...
        ENT1    *               ...so we can load it into rI1
        SRB     0,1             Right shift rAX by the bit number
        JAO     1F              If the bit's already set, do nothing...
        INCA    1               ...else set it
1H      SLB     0,1             Shift the bit back left to its place       
        STA     BTARR,3         Store word back where we got it from 
        LDX     NUM             Load number back into rX...
        INCX    0,2             ...and add the factor once... 
        INCX    0,2             ...and twice (num += factor * 2)
        CMPX    SVSIZE          If number <= sieve size...
        JLE     SETLOOP         ...continue marking non-primes...
        INC2    2               ...else bump factor to next odd number  
        CMP2    SVSQRT          If factor > the sqrt of sieve size...
        JG      CNTPRM          ...we can end this run...
        JMP     QLOOP           ...else continue
* End of set bit loop

* Let's count the primes found in this run
CNTPRM  ENT2    LTWDCT          Load sieve word count into rI2
        ENT3    LTRBTCT         Load remainder bit count into rI3
        STZ     PRMCNT          Zero prime count 
        J3Z     NXTWRD          If remainder bit count == 0, skip to first full word

* Start of word loop        
WRDLOOP LDA     BTARR,2         Load word into rA

* Start of bit loop
BITLOOP JAO     1F              If right bit is set, do nothing
        LDX     PRMCNT          Load prime count, ...
        INCX    1               ...increase it...
        STX     PRMCNT          ...and store it back
1H      SRB     1               Shift to next bit
        DEC3    1               Decrease number of bits to process
        J3P     BITLOOP         If there's a bit left to look at, continue
* End of bit loop

NXTWRD  STZ     BTARR,2         Clear word we've processed
        J2Z     PRTRSLT         If we've processed all words, print result
        DEC2    1               Decrease number of words to process
        ENT3    LTBPW           Set bits to process to number of bits per word
        JMP     WRDLOOP         Continue processing
* End of word loop

* Compose result text and print it
PRTRSLT LDA     PRMCNT          Load prime count in rA so we can convert             
        CHAR    
        STX     PCTXT           Store prime count text
        
        INC4    1               Increase run count
        ENTA    0,4             Load run count into rA for conversion
        CHAR    
        STX     RCTXT           Store run count text
        
        ENT1    CKTXT           Set move target to second conclusion word
        ENT3    0               Start at beginning of check table

* Start of check loop
CHKLOOP LDA     CHCKTBL,3       Load sieve size from check table
        JAN     SVUNKNW         If we sieve size < 0, we have no answer
        CMPA    SVSIZE          If check table sieve size equals ours...
        JE      CHKVAL          ...check its value
        INC3    2               Move to next check table record
        JMP     CHKLOOP         Continue checking
* End of check loop

* Update print text to show what we found
CHKVAL  MOVE    SPACES          Put spaces in second conclusion word
        DEC1    2               Set move target to first conclusion word
        LDX     PRMCNT          Load prime count so we can check it
        CMPX    CHCKTBL+1,3     If check table value doesn't match ours...
        JNE     1F              ...then we'll say so...
        MOVE    RIGHT           ...else we report correct result
        JMP     DOPRINT         Time to print  
1H      MOVE    WRONG           Our result didn't match check table
        JMP     DOPRINT         Time to print
SVUNKNW MOVE    WN              Put end of "unknown" in second conclusion word
        DEC1    2               Set move target to first conclusion word...
        MOVE    UNKNO           ...and put start of "unknown", there 

* Print run result
DOPRINT JBUS    *(PRNTR)        Wait for printer to be available
        OUT     RSLTTXT(PRNTR)  Print result text
        JMP     START           Start next run

** Result text template

RSLTTXT ALF     "RUN: "
RCTXT   CON     0
        ALF     ", PRI"
        ALF     "MES: "
PCTXT   CON     0
        ALF     ", RES"
        ALF     "ULT: "
        CON     0
CKTXT   CON     0
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "
        ALF     "     "

        END     START