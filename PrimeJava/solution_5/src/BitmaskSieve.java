import java.util.HashMap;
import java.util.Map;

public class BitmaskSieve {
	
	private static final long TIME = 5000;
	private static final long WARMUP_TIME = 4000;
	private static final Map<Integer, Integer> VALIDATION_DATA;
	private static long[] MASKS = {
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 0
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 1
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 2
		0b1001001001001001001001001001001001001001001001001001001001001001L, // 3
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 4
		0b0001000010000100001000010000100001000010000100001000010000100001L, // 5
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 6
		0b1000000100000010000001000000100000010000001000000100000010000001L, // 7
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 8
		0b1000000001000000001000000001000000001000000001000000001000000001L, // 9
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 10
		0b0000000010000000000100000000001000000000010000000000100000000001L, // 11
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 12
		0b0000000000010000000000001000000000000100000000000010000000000001L, // 13
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 14
		0b0001000000000000001000000000000001000000000000001000000000000001L, // 15
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 16
		0b0000000000001000000000000000010000000000000000100000000000000001L, // 17
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 18
		0b0000001000000000000000000100000000000000000010000000000000000001L, // 19
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 20
		0b1000000000000000000001000000000000000000001000000000000000000001L, // 21
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 22
		0b0000000000000000010000000000000000000000100000000000000000000001L, // 23
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 24
		0b0000000000000100000000000000000000000010000000000000000000000001L, // 25
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 26
		0b0000000001000000000000000000000000001000000000000000000000000001L, // 27
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 28
		0b0000010000000000000000000000000000100000000000000000000000000001L, // 29
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 30
		0b0100000000000000000000000000000010000000000000000000000000000001L, // 31
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 32
		0b0000000000000000000000000000001000000000000000000000000000000001L, // 33
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 34
		0b0000000000000000000000000000100000000000000000000000000000000001L, // 35
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 36
		0b0000000000000000000000000010000000000000000000000000000000000001L, // 37
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 38
		0b0000000000000000000000001000000000000000000000000000000000000001L, // 39
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 40
		0b0000000000000000000000100000000000000000000000000000000000000001L, // 41
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 42
		0b0000000000000000000010000000000000000000000000000000000000000001L, // 43
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 44
		0b0000000000000000001000000000000000000000000000000000000000000001L, // 45
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 46
		0b0000000000000000100000000000000000000000000000000000000000000001L, // 47
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 48
		0b0000000000000010000000000000000000000000000000000000000000000001L, // 49
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 50
		0b0000000000001000000000000000000000000000000000000000000000000001L, // 51
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 52
		0b0000000000100000000000000000000000000000000000000000000000000001L, // 53
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 54
		0b0000000010000000000000000000000000000000000000000000000000000001L, // 55
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 56
		0b0000001000000000000000000000000000000000000000000000000000000001L, // 57
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 58
		0b0000100000000000000000000000000000000000000000000000000000000001L, // 59
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 60
		0b0010000000000000000000000000000000000000000000000000000000000001L, // 61
		0b0000000000000000000000000000000000000000000000000000000000000000L, // 62
		0b1000000000000000000000000000000000000000000000000000000000000001L  // 63
	};
	
	static {
		VALIDATION_DATA = new HashMap<>();
		VALIDATION_DATA.put(10, 4);
		VALIDATION_DATA.put(100, 25);
		VALIDATION_DATA.put(1000, 168);
		VALIDATION_DATA.put(10000, 1229);
		VALIDATION_DATA.put(100000, 9592);
		VALIDATION_DATA.put(1000000, 78498);
		VALIDATION_DATA.put(10000000, 664579);
		VALIDATION_DATA.put(100000000, 5761455);
	}
	
	private final int sieveSize;
	private final long[] data;
	
	
	public BitmaskSieve(int sieveSize) {
		int highestPosition = sieveSize/64;
		this.sieveSize = sieveSize;
		this.data = new long[highestPosition+1];
	}
	
	public void runSieve() {
		int q = (int) Math.sqrt(sieveSize);
		for (int factor = 3; factor <= Math.min(q, 63); factor += 2) {
			performSieveForFactorsBelow64(factor);
		}
		for (int factor = 65; factor <= q; factor += 2) {
			performSieveForFactorsAbove64(factor);
		}
	}

	public int countPrimes() {
		int count = 0;
		for (int i = 0; i < data.length; i++) {
			long current = data[i];
			int startBit = 1;
			int endBit = 64;
			if (i == 0) {
				startBit = 3; // make sure to not count 0,1 as prime
				count = 1; // count 2 as prime as well
			}
			if (i == data.length-1) {
				endBit = sieveSize & 0x0000_003F; // make sure to not overflow
			}
			for (int b = startBit; b < endBit; b += 2) {
				if (isPrime(current, b)) {
					count++;
				}
			}
		}
		return count;
	}
	
	private static void warmup() {
		long start = System.currentTimeMillis();
		while ((System.currentTimeMillis() - start) < WARMUP_TIME) {
			BitmaskSieve sieve = new BitmaskSieve(1_000_000);
			sieve.runSieve();
		}
	}

	private static void validate() {
		for (Map.Entry<Integer, Integer> test: VALIDATION_DATA.entrySet()) {
			BitmaskSieve sieve = new BitmaskSieve(test.getKey());
			sieve.runSieve();
			if (sieve.countPrimes() != test.getValue().intValue()) {
				throw new IllegalStateException("The sieve is buggy");
			}
		}
	}
	
	public static void main(String args[]) {
		warmup();
		validate();

		long start = System.currentTimeMillis();
		int passes = 0;
		while ((System.currentTimeMillis() - start) < TIME) {
			BitmaskSieve sieve = new BitmaskSieve(1_000_000);
			sieve.runSieve();
			passes++;
		}
		long delta = System.currentTimeMillis() - start;
		double duration = delta / 1000d;
		System.out.printf("%s;%d;%f;%d;algorithm=%s,faithful=yes,bits=%d\n",
				"BitmaskSieve", passes, duration, 1, "base", 1);
	}
	
	
	private static boolean isPrime(long data, long bitPosition) {
		return (data & (1L << bitPosition)) == 0;
	}
	
	/**
	 * When factor is smaller 64, we can set multiple bits at once using
	 * a mask with multiple bits set. So we access every long exactly once
	 * for each factor.
	 */
	private void performSieveForFactorsBelow64(int factor) {
		if (factor >= 64 || ((factor & 1) == 0)) {
			throw new IllegalArgumentException();
		}
		if (isPrime(data[0], factor)) {
			
			int posHigh = 0;
			int posLow = 2*factor;
			// in case of an overflow, carry on the bit
			if (posLow >= 64) {
				posHigh++;
				posLow -= 64;
			}

			int mod = 64 % factor;
			long mask = MASKS[factor];
			
			data[posHigh] |= mask << posLow;
			posHigh++;
			posLow -= factor;

			while (posHigh < data.length) {
				posLow -= mod;
				if (posLow < 0) {
					posLow += factor;
				}
				data[posHigh] |= mask << posLow;
				posHigh++;
			}
		}
	}
	
	/**
	 * When factor is bigger or equal to 64, we know for sure that every bit is 
	 * stored in a different long. For this reason we can spare the logic to
	 * save the current log locally to avoid array access.
	 */
	private void performSieveForFactorsAbove64(int factor) {
		int incHigh = factor >>> 6; 		// divide by 64
		int incLow = factor & 0x0000_003F;	// mod 64
		if (isPrime(data[incHigh], incLow)) {
			int posHigh = 2*incHigh;
			int posLow = 2*incLow;
			// in case of an overflow, carry on the bit
			if (posLow >= 64) {
				posHigh++;
				posLow -= 64;
			}

			while (posHigh < data.length) {
				data[posHigh] |= (1L << posLow);
				posHigh += incHigh;
				posLow += incLow;
				// in case of an overflow, carry on the bit
				if (posLow >= 64) {
					posHigh++;
					posLow -= 64;
				}
			}
		}
	}
}
